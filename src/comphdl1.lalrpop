use parser::{CompInfo, BitArrayDef, BidirectionalRange};

grammar;

pub File: Vec<(CompInfo, Vec<CompInfo>)> = {
    CompDef*
};

pub CompCall: CompInfo = {
    <n: Name> <i: Inputs> <o: ("->" <Outputs>)?> => {
        let o = o.unwrap_or(vec![]);
        CompInfo::new(n, i, o)
    },
};

// Definition, for new components
pub CompDef: (CompInfo, Vec<CompInfo>) = {
    "component" <CompCall> "{" <CompBody> "}",
};

pub CompBody: Vec<CompInfo> = {
    <v: BodyStatement*> => {
        v.into_iter().filter_map(|x| x).collect()
    }
};

// Definition body: component calls separated by ";"
pub BodyStatement: Option<CompInfo> = {
    <CompCall> ";" => Some(<>),
    <Assignment> ";" => Some(<>),
    Comment => None,
};

pub Assignment: CompInfo = {
    <a: Outputs> "=" <b: Outputs> => {
        CompInfo::new("actually, I'm just an assignment".into(),
            b,
            a
        )
    }
};

// Right now comments are only allowed inside the body
pub Comment = {
    // C-style (non-nested)
    r"/[*]([^*]|([*][^/]))*[*]/",
    // C++
    r"//.*",
    // Python
    r"#.*",
};

// [a-zA-Z0-9_]
pub Word: String = {
    r"([_\pL][_0-9\pL]*)" => format!("{}", <>),
};

pub Name = Word;

pub Inputs: Vec<BitArrayDef> = {
    // (a, b)
    "(" <BitArrayArgs> ")",
};

// pub Outputs = Inputs;
pub Outputs: Vec<BitArrayDef> = {
    // (a, b)
    "(" <BitArrayArgs> ")",
    // x
    BitArray => vec![<>],
};

pub BitArray: BitArrayDef = {
    Word => BitArrayDef::from_bit(<>),
    <w: Word> <r: Range> => BitArrayDef::new(w, vec![r]),
};

pub BitArrayArgs = Comma<BitArray>;

pub Range: BidirectionalRange = {
    "[" <a: Number> ":" <b: Number> "]" => BidirectionalRange(a, b)
};

pub Number: u64 = {
    r"[0-9]+" => <>.parse().unwrap()
};

pub VarArgs = Comma<Word>;

// Matches anything from "" to "a,b,c" or even "a,"
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
